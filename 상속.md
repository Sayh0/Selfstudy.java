# 상속
객체지향의 목표 중 가장 중요한 것은 재활용성. 상속은 이 재활용성을 극대화시킨 프로그래밍 기법이자, 동시에 객제치향을 복잡하게 하는 원인.   
**상속**Inheritance 의 사전적 의미는 물려준다는 의미. 어떤 객체가 있을 때 그 객체의 필드(변수)와 메소드를 다른 객체가 물려받을 수 있는 기능을 상속이라고 한다. 많이 썼던 코드를 통해 상속에 대해 알아보자.   
   
   
```java
 class Calculator{
    int left, right;
      
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
      
    public void sum(){
        System.out.println(this.left+this.right);
    }
      
    public void avg(){
        System.out.println((this.left+this.right)/2);
    }
}
  
public class CalculatorDemo4 {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();       
          
        Calculator c2 = new Calculator();
        c2.setOprands(20, 40);
        c2.sum();       
        c2.avg();
    }
  
}
```
객체 Calculator는 sum과 avg 메소드를 가지고 있음. 여기에 빼기 기능의 substract를 추가하려면?
```java
Calculator c1 = new Calculator();
c1.setOprands(10,20);
c1.sum();
c1.avg();
c1.substract();
```
단, 아래같은 경우 객체에 메소드를 추가할 수 없음.
* 객체를 자신이 만들지 않아서 소스를 변경 불가. 변경 해도 원 소스를 업데이트하면 추가했던 subtract가 사라짐.
* 객체가 다양한 곳에 사용되고 있는 경우, subtract가 필요하지 않는 곳에서도 불필요하게 포함될 수 있음.
기존 객체를 유지하면서 기능을 추가하는 멋진 방법이 없을까? 이럴 때 쓰는게 **상속**. 기존 객체는 기능을 물려준다는 의미에서 부모 객체(또는 상위Super 클래스), 새 객체는 기존 객체의 기능을 물려받아서 자식 객체(또는 하위Sub 클래스). 이 방법을 이용해 코드를 수정한다면,
   
```java
class Calculator {
	int left, right;
	
	public void setOprands(int left, int right) {
		this.left = left;
		this.right = right;
	}
	
	public void sum() {
		System.out.println(this.left + this.right);	
	}
	
	public void avg() {
		System.out.println((this.left + this.right) / 2 );
	}
	
}

class SubstractionableCalculator extends Calculator {
	public void substract() {
	System.out.println(this.left - this.right);	
	}
	
}
public class CalculatorDemo1 {
	
	public static void main(String[] args) {
		
		SubstractionableCalculator c1 = new SubstractionableCalculator();
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.substract();
	}

}
```
실행결과는
```
30
15
-10
```
위 코드를 하나씩 뜯어보자. 먼저
```java
class SubstractionableCalculator extends Calculator {
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
```
새로운 클래스인 SubstractionableCalculator 정의. 이 클래스의 본체에는 subtract 라는 메소드만이 존재한다. 하지만 이 클래스를 인스턴스화한 c1은 아래와 같이 정의하지 않은 메소드들을 호출하고 있고, 잘 동작한다.
```java
SubstractionableCalculator c1 = new SubstractionableCalculator();
c1.setOprands(10, 20);
c1.sum();
c1.avg();
c1.substract();
```
가능한 이유는 바로
```java
class SubstractionableCalculator extends Calculator {
```
에서 `extends Calculator` 덕분. 이건 클래스 Calculator를 상속 받는다는 의미이다. 따라서 SubstractionableCalculator는 Calculator에서 정의한 메소드들(setOrpnads, sum, avg)을 사용할 수 있게 되었다. 이게 참 좋은게, 코드 중복을 막을 수 있을뿐더러 부모 클래스를 손보면 자식 클래스도 자동으로 수정된다.   
Calculator를 상속 받는 클래스를 하나 더 만들어 보기로 하자. 곱하기 할 수 있는 클래스로.
```java
class MulCalculator extends Calculator {
	public void multiplication() {
		System.out.println(this.left * this.right);
	}
}
public class CalculatorDemo2 {
	
	public static void main(String[] args) {
		
		MulCalculator c1 = new MulCalculator() ;
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.multiplication();
	}

}
```
결과는
```
30
15
200
```
그럼 상속한 클래스를 다시 상속하는건? 가능하다. 아래 코드는 곱하기가 가능한 클래스인 MulCalculator를 상속받고 있다.
```java
class DivCalculator extends MulCalculator {
	public void division() {
		System.out.println(this.left / this.right);
	}
	
}
public class CalculatorDemo3 {
	
	public static void main(String[] args) {
		
		DivCalculator c1 = new DivCalculator();
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.multiplication();
		c1.division();
		
	}

}
```
   
## 상속과 생성자
그렇다면 상속은 장점만 있을까? 물론 아니다. 상속의 효율만큼 단점도 있음(복잡도의 증가). 다만 이것을 이해하기 위해선 기본 생성자의 성질에 대한 이해를 선행해야 함.
```java
public class ConstructorDemo {
	public static void main(String[] args) {
		ConstructorDemo c = new ConstructorDemo();
	}

}
```
이 코드에선 오류가 발생하지 않음. ConstructorDemo 객체 생성 시 자동으로 생성자를 만들어주기 때문.
```java
public class ConstructorDemo {
	public ConstructorDemo (int param1) {} // 매개변수 있는 생성자
	public static void main(String[] args) {
		ConstructorDemo c = new ConstructorDemo (); // 오류 발생
	}
	
}
```
그러나 위 코드에선 오류가 발생. 매개변수가 있는 생성자가 있을 땐 자동으로 기본 생성자를 만들어주지 않음. 따라서 위 코드에선 존재하지 않는 생성자를 호출하고 있는 것. 이 문제를 해결하기 위해선 기본 생성자를 추가해주어야 함.
```java
public class ConstructorDemo {
	public ConstructorDemo() {} // 기본 생성자 추가
	public ConstructorDemo (int param1) {}
	public static void main(String[] args) {
		ConstructorDemo c = new ConstructorDemo ();
	}

}
```
<hr/>
이제 맛보기 끝. 본론이다. 아까 상속에서 봤던 코드에서 몇 부분을 수정해보았다.  


  
```java
class Calculator {
	int left, right;
	
	public void setOprands(int left, int right) {
		this.left = left;
		this.right = right;
	}
	public void sum() {
		System.out.println(this.left + this.right);
	}	
	public void avg() {
		System.out.println((this.left + this.right) / 2);
	}	
}
class SubstractionableCalculator extends Calculator {
	public SubstractionableCalculator(int left, int right) { // 달라진 부분. 여기부터
		this.left = left;
		this.right = right; 
	} // 여기까지가 추가됨
	
	public void substract() {
		System.out.println(this.left - this.right);
	}
}
public class CalculatorConstructorDemo4 {
	public static void main(String[] args) {
		SubstractionableCalculator c1 = new SubstractionableCalculator(10,20); //1 10, 20이 추가됨
		c1.sum();
		c1.avg();
		c1.substract();
	}

}
```
SubstractionableCalculator의 생성자로 left와 right의 값을 받아서 초기화하고 있음. 만약 클래스 Calculator가 메소드 setOprands가 아닌 생성자를 통해 left, right의 값을 설정하도록 하고 싶다면 아래와 같이 코드를 변경해야 함.
```java
class Calculator {
    int left, right;
     
    public Calculator(int left, int right){ //수정된 부분
        this.left = left; 
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
 
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```
그치만 이 코드를 실행하면 오류가 발생함. 상위 클래스인 Calculator 의 생성자가 존재하지 않기 때문. 하위 클래스가 호출될 때 자동으로 상위 클래스의 기본 생성자를 호출하게 됨. 근데 상위 클래스에 매개변수가 있는 생성자가 있으면 자바는 자동으로 상위 클래스의 기본 생성자를 만들어주지 않음. 따라서 불러올 상위 클래스도 없으니, 에러가 발생하는 것. 해결을 위해 상위 클래스에 기본 생성자를 추가한다.
```java
class Calculator {
    int left, right;
     
    public Calculator(){} // 기본 생성자 추가.
    
    public Calculator(int left, int right){
        this.left = left; 
        this.right = right;
    }
    
... 이하 생략
```
## super
super는 상위 클래스를 가리키는 키워드이다. 예제 코드를 통해 super의 사용법을 알아보자.
```java
class Calculator {
    int left, right;
     
    public Calculator(){}
     
    public Calculator(int left, int right){
        this.left = left;
        this.right = right;
    }
     
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
 
    public void sum() {
        System.out.println(this.left + this.right);
    }
 
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        super(left, right); // 					super 클래스가 사용된 부분
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
 
public class CalculatorConstructorDemo5 {
    public static void main(String[] args) {
        SubstractionableCalculator c1 = new SubstractionableCalculator(10, 20);
        c1.sum();
        c1.avg();
        c1.substract();
    }
}
```java
...
class SubstractionableCalculator extends Calculator {
    public SubstractionableCalculator(int left, int right) {
        super(left, right);
    }
 
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
```
super 클래스는 부모 클래스이다. 여기에 ()가 붙으면 부모 클래스의 생성자를 의미하는 것이다. 이렇게 하면 부모 클래스의 기본 생성자가 없어져도 오류가 발생하지 않는다.
주의점 : 하위 클래스 생성자에서 super를 사용할 땐 무조건 super를 가장 먼저 나타내야 한다. 부모가 초기화되기 전에 자식이 초기화될 수는 없다 정도로 기억하자.







