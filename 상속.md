# 상속
객체지향의 목표 중 가장 중요한 것은 재활용성. 상속은 이 재활용성을 극대화시킨 프로그래밍 기법이자, 동시에 객제치향을 복잡하게 하는 원인.   
**상속**Inheritance 의 사전적 의미는 물려준다는 의미. 어떤 객체가 있을 때 그 객체의 필드(변수)와 메소드를 다른 객체가 물려받을 수 있는 기능을 상속이라고 한다. 많이 썼던 코드를 통해 상속에 대해 알아보자.   
   
   
```java
 class Calculator{
    int left, right;
      
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
      
    public void sum(){
        System.out.println(this.left+this.right);
    }
      
    public void avg(){
        System.out.println((this.left+this.right)/2);
    }
}
  
public class CalculatorDemo4 {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();       
          
        Calculator c2 = new Calculator();
        c2.setOprands(20, 40);
        c2.sum();       
        c2.avg();
    }
  
}
```
객체 Calculator는 sum과 avg 메소드를 가지고 있음. 여기에 빼기 기능의 substract를 추가하려면?
```java
Calculator c1 = new Calculator();
c1.setOprands(10,20);
c1.sum();
c1.avg();
c1.substract();
```
단, 아래같은 경우 객체에 메소드를 추가할 수 없음.
* 객체를 자신이 만들지 않아서 소스를 변경 불가. 변경 해도 원 소스를 업데이트하면 추가했던 subtract가 사라짐.
* 객체가 다양한 곳에 사용되고 있는 경우, subtract가 필요하지 않는 곳에서도 불필요하게 포함될 수 있음.
기존 객체를 유지하면서 기능을 추가하는 멋진 방법이 없을까? 이럴 때 쓰는게 **상속**. 기존 객체는 기능을 물려준다는 의미에서 부모 객체(또는 상위Super 클래스), 새 객체는 기존 객체의 기능을 물려받아서 자식 객체(또는 하위Sub 클래스). 이 방법을 이용해 코드를 수정한다면,
   
```java
class Calculator {
	int left, right;
	
	public void setOprands(int left, int right) {
		this.left = left;
		this.right = right;
	}
	
	public void sum() {
		System.out.println(this.left + this.right);	
	}
	
	public void avg() {
		System.out.println((this.left + this.right) / 2 );
	}
	
}

class SubstractionableCalculator extends Calculator {
	public void substract() {
	System.out.println(this.left - this.right);	
	}
	
}
public class CalculatorDemo1 {
	
	public static void main(String[] args) {
		
		SubstractionableCalculator c1 = new SubstractionableCalculator();
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.substract();
	}

}
```
실행결과는
```
30
15
-10
```
위 코드를 하나씩 뜯어보자. 먼저
```java
class SubstractionableCalculator extends Calculator {
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
```
새로운 클래스인 SubstractionableCalculator 정의. 이 클래스의 본체에는 subtract 라는 메소드만이 존재한다. 하지만 이 클래스를 인스턴스화한 c1은 아래와 같이 정의하지 않은 메소드들을 호출하고 있고, 잘 동작한다.
```java
SubstractionableCalculator c1 = new SubstractionableCalculator();
c1.setOprands(10, 20);
c1.sum();
c1.avg();
c1.substract();
```
가능한 이유는 바로
```java
class SubstractionableCalculator extends Calculator {
```
에서 `extends Calculator` 덕분. 이건 클래스 Calculator를 상속 받는다는 의미이다. 따라서 SubstractionableCalculator는 Calculator에서 정의한 메소드들(setOrpnads, sum, avg)을 사용할 수 있게 되었다. 이게 참 좋은게, 코드 중복을 막을 수 있을뿐더러 부모 클래스를 손보면 자식 클래스도 자동으로 수정된다.   
Calculator를 상속 받는 클래스를 하나 더 만들어 보기로 하자. 곱하기 할 수 있는 클래스로.
```java
class MulCalculator extends Calculator {
	public void multiplication() {
		System.out.println(this.left * this.right);
	}
}
public class CalculatorDemo2 {
	
	public static void main(String[] args) {
		
		MulCalculator c1 = new MulCalculator() ;
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.multiplication();
	}

}
```
결과는
```
30
15
200
```
그럼 상속한 클래스를 다시 상속하는건? 가능하다. 아래 코드는 곱하기가 가능한 클래스인 MulCalculator를 상속받고 있다.
```java
class DivCalculator extends MulCalculator {
	public void division() {
		System.out.println(this.left / this.right);
	}
	
}
public class CalculatorDemo3 {
	
	public static void main(String[] args) {
		
		DivCalculator c1 = new DivCalculator();
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.multiplication();
		c1.division();
		
	}

}
```
   
## 상속과 생성자
그렇다면 상속은 장점만 있을까? 물론 아니다. 상속의 효율만큼 단점도 있음(복잡도의 증가). 다만 이것을 이해하기 위해선 기본 생성자의 성질에 대한 이해를 선행해야 함.
```java
public class ConstructorDemo {
	public static void main(String[] args) {
		ConstructorDemo c = new ConstructorDemo();
	}

}
```
이 코드에선 오류가 발생하지 않음. ConstructorDemo 객체 생성 시 자동으로 생성자를 만들어주기 때문.
```java
public class ConstructorDemo {
	public ConstructorDemo (int param1) {} // 매개변수 있는 생성자
	public static void main(String[] args) {
		ConstructorDemo c = new ConstructorDemo (); // 오류 발생
	}
	
}
```
그러나 위 코드에선 오류가 발생. 매개변수가 있는 생성자가 있을 땐 자동으로 기본 생성자를 만들어주지 않음. 따라서 위 코드에선 존재하지 않는 생성자를 호출하고 있는 것. 이 문제를 해결하기 위해선
```java
public class ConstructorDemo {
	public ConstructorDemo() {} // 기본 생성자 추가
	public ConstructorDemo (int param1) {}
	public static void main(String[] args) {
		ConstructorDemo c = new ConstructorDemo ();
	}

}
```
기본 생성자를 추가해주어야 함.









