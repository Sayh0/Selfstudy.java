# 상속
객체지향의 목표 중 가장 중요한 것은 재활용성. 상속은 이 재활용성을 극대화시킨 프로그래밍 기법이자, 동시에 객제치향을 복잡하게 하는 원인.   
**상속**Inheritance 의 사전적 의미는 물려준다는 의미. 어떤 객체가 있을 때 그 객체의 필드(변수)와 메소드를 다른 객체가 물려받을 수 있는 기능을 상속이라고 한다. 많이 썼던 코드를 통해 상속에 대해 알아보자.   
   
   
```java
 class Calculator{
    int left, right;
      
    public void setOprands(int left, int right){
        this.left = left;
        this.right = right;
    }
      
    public void sum(){
        System.out.println(this.left+this.right);
    }
      
    public void avg(){
        System.out.println((this.left+this.right)/2);
    }
}
  
public class CalculatorDemo4 {
      
    public static void main(String[] args) {
          
        Calculator c1 = new Calculator();
        c1.setOprands(10, 20);
        c1.sum();       
        c1.avg();       
          
        Calculator c2 = new Calculator();
        c2.setOprands(20, 40);
        c2.sum();       
        c2.avg();
    }
  
}
```
객체 Calculator는 sum과 avg 메소드를 가지고 있음. 여기에 빼기 기능의 substract를 추가하려면?
```java
Calculator c1 = new Calculator();
c1.setOprands(10,20);
c1.sum();
c1.avg();
c1.substract();
```
단, 아래같은 경우 객체에 메소드를 추가할 수 없음.
* 객체를 자신이 만들지 않아서 소스를 변경 불가. 변경 해도 원 소스를 업데이트하면 추가했던 subtract가 사라짐.
* 객체가 다양한 곳에 사용되고 있는 경우, subtract가 필요하지 않는 곳에서도 불필요하게 포함될 수 있음.
기존 객체를 유지하면서 기능을 추가하는 멋진 방법이 없을까? 이럴 때 쓰는게 **상속**. 기존 객체는 기능을 물려준다는 의미에서 부모 객체(또는 상위Super 클래스), 새 객체는 기존 객체의 기능을 물려받아서 자식 객체(또는 하위Sub 클래스). 이 방법을 이용해 코드를 수정한다면,
   
```java
class Calculator {
	int left, right;
	
	public void setOprands(int left, int right) {
		this.left = left;
		this.right = right;
	}
	
	public void sum() {
		System.out.println(this.left + this.right);	
	}
	
	public void avg() {
		System.out.println((this.left + this.right) / 2 );
	}
	
}

class SubstractionableCalculator extends Calculator {
	public void substract() {
	System.out.println(this.left - this.right);	
	}
	
}
public class CalculatorDemo1 {
	
	public static void main(String[] args) {
		
		SubstractionableCalculator c1 = new SubstractionableCalculator();
		c1.setOprands(10,20);
		c1.sum();
		c1.avg();
		c1.substract();
	}

}
```
실행결과는
```
30
15
-10
```
위 코드를 하나씩 뜯어보자. 먼저
```java
class SubstractionableCalculator extends Calculator {
    public void substract() {
        System.out.println(this.left - this.right);
    }
}
```
새로운 클래스인 SubstractionableCalculator 정의. 이 클래스의 본체에는 subtract 라는 메소드만이 존재한다. 하지만 이 클래스를 인스턴스화한 c1은 아래와 같이 정의하지 않은 메소드들을 호출하고 있고, 잘 동작한다.
```java
SubstractionableCalculator c1 = new SubstractionableCalculator();
c1.setOprands(10, 20);
c1.sum();
c1.avg();
c1.substract();
```
가능한 이유는 바로
```java
class SubstractionableCalculator extends Calculator {
```
에서 `extends Calculator` 덕분. 이건 클래스 Calculator를 상속 받는다는 의미이다. 따라서 

