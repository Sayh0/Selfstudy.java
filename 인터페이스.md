# 인터페이스
인터페이스는 **abstract**, **final**과 같은 규제 수단이다. 
어떤 객체가 있고, 그 객체가 특정한 인터페이스를 사용한다면 반드시 그 특정 인터페이스의 메소드를 구현해야 한다.
만약 인터페이스에서 강제하고 있는 메소드를 구현하지 않는다면 이 애플리케이션은 컴파일되지 않는다.
무슨 말인지 모르겠으니 예제로 이해해 보자.

## 예제
단순한 예제부터 시작하자.
```java
interface I {
  public void z();
}

class A implements I {
  public void z() {
  }
}
```
클래스 A 뒤의 `implements I`는 **이 클래스가 인터페이스 I 를 구현하고 있다**라는 의미이다.
이는 `inferface I`의 멤버인 `public void z()` 메소드를 클래스 `A`가 반드시 포함하고 있어야 한다는 뜻이다. 
따라서 우선 위 코드는 에러가 없다. 만약 `public void z()`를 삭제한다면 컴파일 에러가 발생할 것이다.<br><br>

상속에서 봤던 것 아니야? 라고 생각할 수 있겠지만, 
상속은 상위 클래스 기능을 하위 클래스가 물려받는 것이고 인터페이스는 하위 클래스의 특정한 메소드를 상위 클래스에 반드시 존재하도록 강제한다.
이러한 규제가 왜 필요한지는 후에 차차 알아보도록 한다.<br>
상속과 다른 점은 또 있는데, 클래스를 선언할 떄는 **class** 를 사용하지만, 인터페이스는 **interface**를 사용한다.
또한 상속은 **extends**를 사용하지만 인터페이스는 **implements**를 사용한다. 결론적으로 이것만 기억하자.
> class A implements I { ...} <br>
> = 클래스 A는 인터페이스 I를 '구현' 한다.

## 쓰임
계산기 예제에 인터페이스를 도입해보자. 
프로젝트에 시간이 모자라서, 계산기 클래스는 개발자 A가 만들고 개발자 B는 클래스를 사용하는 로직을 만들기로 하였다.
개발자 B는 A가 계산기 클래스를 잘 만들어 줄거라고 생각하고 우선 로직을 만들었다.
```java
class CalculatorDummy {
	public void setOprands(int first, int second, int third) {
		
	}
	public int sum() {
		return 60;
	}
	public int avg() {
		return 20;
	}
}
public class CalculatorConsumer {
	public static void main(String[] args ) {
		CalculatorDummy c = new CalculatorDummy();
		c.setOprands(10, 20, 30);
		System.out.println(c.sum() + c.avg());
	}
}
```
여기에 개발자 A가 Calculator 클래스를 완성해서 인계해 주었다.
```java
class Calculator {
    int left, right;
    public void setOprands(int left, int right) {
        this.left = left;
        this.right = right;
    }
    public void sum() {
        System.out.println(this.left + this.right);
    }
    public void avg() {
        System.out.println((this.left + this.right) / 2);
    }
}
```
어라? `setOprands`의 매개변수를 개발자 B는 변수 3개라고 생각했는데, 개발자 A는 의 매개변수를 2개 받고 있다!
꼬였다. 문제를 해결하려면 어떻게 해야 할까? 코드 안에서 협업자간의 약속이 필요하다. <br>
이럴 때 쓰는 것이 인터페이스. 
`Calculator`클래스를 사용할 개발자가 이 클래스가 가지고 있어야 할 메소드를 인터페이스로 만들어서 제공한다.
반대의 경우도 물론 가능하다. 만드는 쪽에서 인터페이스를 제공하는 것이다. 
양쪽의 개발자는 이 인터페이스를 구현한 `Calculator`클래스와 `CalculatorDummy`클래스를 각각 구현한다. <br><br>
이렇게 해서 구현한 코드는 다음과 같다. 우선 약속을 정의한 인터페이스이다.
```java
public interface Calculatable {
	public void setOprands(int first, int second, int third);
	public int sum();
	public int avg();
}
```
다음은 인터페이스를 구현한 가짜 클래스를 임시로 사용해서 만든 애플리케이션이다.
```java
class CalculatorDummy implements Calculatable{
    public void setOprands(int first, int second, int third){
    }
    public int sum(){
        return 60;
    }
    public int avg(){
        return 20;
    }
}
public class CalculatorConsumer {
    public static void main(String[] args) {
        CalculatorDummy c = new CalculatorDummy();
        c.setOprands(10, 20, 30);
        System.out.println(c.sum()+c.avg());
    }
}
```
그 다음은 인터페이스에 따라 구현 된 클래스이다.



